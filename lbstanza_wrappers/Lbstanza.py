
from lbstanza_wrappers.Exporter import Exporter
from lbstanza_wrappers import __version__

class LBStanzaExporter(Exporter):
  """ Exporter with utility functions
  for creating LBStanza code.
  """
  RESERVED_WORDS = [
    "val", "var", "when", "if", "is", "is-not", "else", "defn", "defmethod",
    "defmulti", "lostanza", "public", "new", "to", "through", "by",
    "ptr", "int", "long", "double", "float", "char", "byte",
    "return", "label", "generate", "from", "defstruct", "with",
    "try", "catch", "finally", "attempt", "multifn", "deftype", "not",
    "match", "switch", "let", "let-var" "where", "in", "within", "while",
    "String", "Int", "Double",
  ]

  def dump_autogen_header(self):
    self.lprint("; This file was auto-generated by lbstanza-wrapper")
    self.lprint("; Version {}".format(__version__))
    self.lprint("; Manual editing would be unwise")

  def dump_package_decl(self, prefix, pkgName, imports):
    self.lprint("defpackage {}/{} :".format(prefix, pkgName))
    with self.indented():
      for imp in imports:
        self.lprint("import {}".format(imp))
    self.lprint("")

class FuncDeclExporter(LBStanzaExporter):
  """ Function Declarations Exporter
  """

  def gen_func_type(self, argsList, retType):
    """ Generate the function type declaration
    in the form " (int, int) -> int "
    """
    args = ",".join([x[2] for x in argsList.values()])
    return "({}) -> {}".format(args, retType)

  def dump_static_decl(self, funcs):
    """ Dump static function declarations.
    @NOTE - the lack of prefix - this is because these function
      names are searched for in the compiled objects and must match
      as symbol names.
    """
    for name, data in funcs.items():
      argsList, retData, *others = data
      retType, isVoid, *_ = retData
      voidComment = ""
      if isVoid:
        voidComment = "  ;  void"
      funcType = self.gen_func_type(argsList, retType)
      self.lprint("extern {} : {}{}".format(name, funcType, voidComment))

  def dump_wrapper(self, funcs):
    """ Generate the wrapper lostanza function that is used to make
    consistent calling interface from high stanza code.
    @note: These functions have the `w_` prefix.
    """
    # public lostanza defn w_func_name (v:int) -> int :
    #   val ret = call-c func_name(v)
    #   return ret

    def to_argdecl(k,v):
      return "{}:{}".format(k, v[2])

    for name, data in funcs.items():
      argsList, retData, *others = data
      retType, isVoid, *_ = retData
      argDecls = ", ".join([to_argdecl(k,v) for k,v in argsList.items()])
      fArgs = ", ".join(argsList.keys())

      if isVoid:
        retDecl = "ref<False>"
      else:
        retDecl = retType

      self.lprint("public lostanza defn w_{} ({}) -> {} :".format(name, argDecls, retDecl))
      with self.indented():
        retPrefix = "val ret = "
        if isVoid:
          retPrefix = ""
        self.lprint("{}call-c {}({})".format(retPrefix, name, fArgs))
        if isVoid:
          self.lprint("return false")
        else:
          self.lprint("return ret")

  def dump_func_decls(self, funcs, opts):
    self.dump_autogen_header()
    imports = ["core"]
    self.dump_package_decl(opts.pkg_prefix, opts.pkg_name, imports)
    self.dump_static_decl(funcs)
    self.dump_wrapper(funcs)


class NativeEnumExporter(LBStanzaExporter):
  """ I implemented the original enum exportation code
  before I knew about `defenum` - unfortunately, `defenum`
  wasn't documented anywhere except in a file in the `examples`
  folder at the time I wrote this :(
  In any case - this is a better implementation for standard enum types
  that don't attempt to specify specific integer values.
  If the enum that you are attempting to wrap contains a gap or
  a starting number that is not 0 - then this will likely not work
  because there is no way to control the numbering like there is
  in C.
  """

  def __init__(self, fout, name, enumerators):
    super().__init__(fout)
    self._name = name
    self._enumerators = enumerators

  def dump_enums(self, opts):
    self.dump_autogen_header()

    imports = ["core",]
    self.dump_package_decl(opts.pkg_prefix, self._name, imports)

    self.lprint("public defenum {}:".format(self._name))
    with self.indented():
      for eName, v in self._enumerators :
        self.lprint("{}".format(eName))
    self.lprint("")

    # I add a lostanza constructor for ease of use with
    #  wrappers
    self.lprint("public lostanza defn {} (v:int) -> ref<{}> :".format(self._name, self._name))
    with self.indented():
      self.lprint("return {}(new Int{{v}})".format(self._name))
    self.lprint("")


class EnumExporter(LBStanzaExporter):

  def __init__(self, fout, name, enumerators):
    """
    @param fout Output File Object to export to
    @param name Name of the Enumerator Base Type
    @param enumerators List of tuples of the form (name, value)
      where `name` is the enumerator and 'value' is an integer
    """
    super().__init__(fout)
    self._name = name
    self._enumerators = enumerators

  def to_type(self, eName):
    return "{}".format(eName)

  def dump_enum_deftypes(self):
    self.lprint("public deftype {} <: Equalable".format(self._name))
    for eName, v in self._enumerators :
      self.lprint("public deftype {} <: {}".format(self.to_type(eName), self._name))
    self.lprint("")

    for eName, v in self._enumerators :
      self.lprint("public val {} = new {}".format(eName, self.to_type(eName)))
    self.lprint("")

  def dump_to_int(self):
    self.lprint("public defn to-int (v:{}) -> Int:".format(self._name))
    with self.indented():
      self.lprint("match(v) :")
      with self.indented():
        for eName, v in self._enumerators:
          self.lprint("(x:{}) : {}".format(self.to_type(eName),v))
    self.lprint("")

  def dump_constructor(self):
    self.lprint("public defn {} (v:Int) -> {} :".format(self._name, self._name))
    with self.indented():
      self.lprint("switch {v == _}:")
      with self.indented():
        for eName, v in self._enumerators :
          self.lprint("{} : {}".format(v, eName))
        self.lprint("else: throw(Exception(\"{}: Invalid Enum Value: %_\" % [v]))".format(self._name))
    self.lprint("")

    self.lprint("public lostanza defn {} (v:int) -> ref<{}> :".format(self._name, self._name))
    with self.indented():
      self.lprint("return {}(new Int{{v}})".format(self._name))
    self.lprint("")

  def dump_print(self):
    self.lprint("public defmethod print (o:OutputStream, v:{}) :".format(self._name))
    with self.indented():
      self.lprint("match(v) :")
      with self.indented():
        for eName, v in self._enumerators :
          self.lprint("(x:{}) : print(o, \"{}\")".format(self.to_type(eName), eName))
    self.lprint("")

  def dump_equals(self):
    self.lprint("public defmethod equal? (a:{}, b:{}) -> True|False :".format(self._name, self._name))
    with self.indented():
      self.lprint("to-int(a) == to-int(b)")
    self.lprint("")

  def dump_enums(self, opts):
    self.dump_autogen_header()

    imports = ["core",]
    self.dump_package_decl(opts.pkg_prefix, self._name, imports)
    self.dump_enum_deftypes()
    self.dump_to_int()
    self.dump_constructor()
    self.dump_print()
    self.dump_equals()
